{"version":3,"sources":["../../src/trees/bkd.ts"],"sourcesContent":["import type { Nullable, GenericSorting } from '../types.js'\nimport type { InternalDocumentID } from '../components/internal-document-id-store.js'\n\nexport interface Point {\n  lon: number\n  lat: number\n}\n\nexport interface Node {\n  point: Point\n  docIDs?: InternalDocumentID[]\n  left?: Node\n  right?: Node\n  parent?: Node\n}\n\nexport interface RootNode {\n  root: Nullable<Node>\n}\n\nexport interface GeoSearchResult {\n  point: Point\n  docIDs: InternalDocumentID[]\n}\n\nexport type SortGeoPoints = Nullable<GenericSorting>\n\ninterface SearchTask {\n  node: Nullable<Node>\n  depth: number\n}\n\nconst K = 2 // 2D points\nconst EARTH_RADIUS = 6371e3 // Earth radius in meters\n\nexport function create (): RootNode {\n  return { root: null }\n}\n\nexport function insert (tree: RootNode, point: Point, docIDs: InternalDocumentID[]): void {\n  const newNode: Node = { point, docIDs }\n\n  if (tree.root == null) {\n    tree.root = newNode\n    return\n  }\n\n  let node: Nullable<Node> = tree.root\n  let depth = 0\n\n  while (node !== null) {\n    // Check if the current node's point matches the new point\n    if (node.point.lon === point.lon && node.point.lat === point.lat) {\n      // Merge the new docIDs with the existing ones and remove duplicates\n      const newDocIDs = node.docIDs ?? []\n      node.docIDs = Array.from(new Set([...newDocIDs, ...docIDs || []]))\n      return\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        if (node.left == null) {\n          node.left = newNode\n          return\n        }\n        node = node.left\n      } else {\n        if (node.right == null) {\n          node.right = newNode\n          return\n        }\n        node = node.right\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        if (node.left == null) {\n          node.left = newNode\n          return\n        }\n        node = node.left\n      } else {\n        if (node.right == null) {\n          node.right = newNode\n          return\n        }\n        node = node.right\n      }\n    }\n\n    depth++\n  }\n}\n\nexport function contains (tree: RootNode, point: Point): boolean {\n  let node: Nullable<Node> | undefined = tree.root\n  let depth = 0\n\n  while (node != null) {\n    if (node?.point.lon === point.lon && node.point.lat === point.lat) {\n      return true\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        node = node?.left\n      } else {\n        node = node?.right\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        node = node?.left\n      } else {\n        node = node?.right\n      }\n    }\n\n    depth++\n  }\n\n  return false\n}\n\n// @todo: this is very inefficient. Fix this later.\nexport function removeDocByID (tree: RootNode, point: Point, docID: InternalDocumentID): void {\n  let node: Nullable<Node> | undefined = tree.root\n  let depth = 0\n  let parentNode: Nullable<Node> = null\n  let direction: 'left' | 'right' | null = null\n\n  while (node !== null) {\n    if (node?.point.lon === point.lon && node.point.lat === point.lat) {\n      const index = node.docIDs?.indexOf(docID)\n      if (index !== undefined && index > -1) {\n        // Remove the docID from the array\n        node.docIDs?.splice(index, 1)\n\n        if ((node.docIDs == null) || node.docIDs.length === 0) {\n          // If the node doesn't have any more docIDs, remove the node\n          if (parentNode != null) {\n            if (direction === 'left') {\n              parentNode.left = (node.left !== null) ? node.left : node.right\n            } else if (direction === 'right') {\n              parentNode.right = (node.right !== null) ? node.right : node.left\n            }\n          } else {\n            // If the node to be removed is the root\n            tree.root = ((node.left !== null) ? node.left : node.right) as Node\n          }\n        }\n\n        return\n      }\n    }\n\n    const axis = depth % K\n\n    parentNode = node as Nullable<Node>\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node!.point.lon) {\n        node = node?.left\n        direction = 'left'\n      } else {\n        node = node?.right\n        direction = 'right'\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node!.point.lat) {\n        node = node?.left\n        direction = 'left'\n      } else {\n        node = node?.right\n        direction = 'right'\n      }\n    }\n\n    depth++\n  }\n}\n\nexport function getDocIDsByCoordinates (tree: RootNode, point: Point): Nullable<InternalDocumentID[]> {\n  let node: Nullable<Node> = tree.root\n  let depth = 0\n\n  while (node !== null) {\n    if (node.point.lon === point.lon && node.point.lat === point.lat) {\n      // prettier-ignore\n      return node.docIDs ?? null\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        node = node.left as Nullable<Node>\n      } else {\n        node = node.right as Nullable<Node>\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        node = node.left as Nullable<Node>\n      } else {\n        node = node.right as Nullable<Node>\n      }\n    }\n\n    depth++\n  }\n\n  return null\n}\n\nexport function searchByRadius (\n  node: Nullable<Node>,\n  center: Point,\n  radius: number,\n  inclusive = true,\n  sort: SortGeoPoints = 'asc'\n): GeoSearchResult[] {\n  const stack: Array<{ node: Nullable<Node>, depth: number }> = [{ node, depth: 0 }]\n  const result: GeoSearchResult[] = []\n\n  while (stack.length > 0) {\n    const { node, depth } = stack.pop() as { node: Node, depth: number }\n    if (node === null) continue\n\n    const dist = haversineDistance(center, node.point)\n\n    if (inclusive ? dist <= radius : dist > radius) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    }\n\n    if (node.left != null) {\n      stack.push({ node: node.left, depth: depth + 1 })\n    }\n    if (node.right != null) {\n      stack.push({ node: node.right, depth: depth + 1 })\n    }\n  }\n\n  if (sort) {\n    result.sort((a, b) => {\n      const distA = haversineDistance(center, a.point)\n      const distB = haversineDistance(center, b.point)\n      return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA\n    })\n  }\n\n  return result\n}\n\nexport function searchByPolygon (root: Nullable<Node>, polygon: Point[], inclusive = true, sort: SortGeoPoints = null): GeoSearchResult[] {\n  const stack: SearchTask[] = [{ node: root, depth: 0 }]\n  const result: GeoSearchResult[] = []\n\n  while (stack.length > 0) {\n    const task = stack.pop()\n    if ((task == null) || (task.node == null)) continue\n\n    const { node, depth } = task\n    const nextDepth = depth + 1\n\n    if (node.left != null) {\n      stack.push({ node: node.left, depth: nextDepth })\n    }\n\n    if (node.right != null) {\n      stack.push({ node: node.right, depth: nextDepth })\n    }\n\n    const isInsidePolygon = isPointInPolygon(polygon, node.point)\n\n    if (isInsidePolygon && inclusive) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    } else if (!isInsidePolygon && !inclusive) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    }\n  }\n\n  const centroid = calculatePolygonCentroid(polygon)\n\n  if (sort !== null) {\n    result.sort((a, b) => {\n      const distA = haversineDistance(centroid, a.point)\n      const distB = haversineDistance(centroid, b.point)\n      return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA\n    })\n  }\n\n  return result\n}\n\nfunction calculatePolygonCentroid (polygon: Point[]): Point {\n  let totalArea = 0\n  let centroidX = 0\n  let centroidY = 0\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].lon\n    const yi = polygon[i].lat\n    const xj = polygon[j].lon\n    const yj = polygon[j].lat\n\n    const areaSegment = xi * yj - xj * yi\n    totalArea += areaSegment\n\n    centroidX += (xi + xj) * areaSegment\n    centroidY += (yi + yj) * areaSegment\n  }\n\n  totalArea /= 2\n\n  centroidX /= (6 * totalArea)\n  centroidY /= (6 * totalArea)\n\n  return { lon: centroidX, lat: centroidY }\n}\n\nfunction isPointInPolygon (polygon: Point[], point: Point): boolean {\n  let isInside = false\n  const x = point.lon; const y = point.lat\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].lon; const yi = polygon[i].lat\n    const xj = polygon[j].lon; const yj = polygon[j].lat\n\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n    if (intersect) isInside = !isInside\n  }\n\n  return isInside\n}\n\nfunction haversineDistance (coord1, coord2): number {\n  const P = Math.PI / 180\n  const lat1 = coord1.lat * (P)\n  const lat2 = coord2.lat * (P)\n  const deltaLat = (coord2.lat - coord1.lat) * (P)\n  const deltaLon = (coord2.lon - coord1.lon) * (P)\n\n  const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\n            Math.cos(lat1) * Math.cos(lat2) *\n            Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n\n  return EARTH_RADIUS * c\n}\n"],"names":["K","EARTH_RADIUS","create","root","insert","tree","point","docIDs","newNode","node","depth","lon","lat","newDocIDs","Array","from","Set","axis","left","right","contains","removeDocByID","docID","parentNode","direction","index","indexOf","undefined","splice","length","getDocIDsByCoordinates","searchByRadius","center","radius","inclusive","sort","stack","result","pop","dist","haversineDistance","push","a","b","distA","distB","toLowerCase","searchByPolygon","polygon","task","nextDepth","isInsidePolygon","isPointInPolygon","centroid","calculatePolygonCentroid","totalArea","centroidX","centroidY","i","j","xi","yi","xj","yj","areaSegment","isInside","x","y","intersect","coord1","coord2","P","Math","PI","lat1","lat2","deltaLat","deltaLon","sin","cos","c","atan2","sqrt"],"mappings":"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"}